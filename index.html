<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css">
    <title>Sprint2_1_React</title>
</head>

<body>

    <div class="container">

        <h1>Sprint 2.1 React</h1>

        <h3 class="title"> Ejercicio 1.1: ARROW FUNCTIONS</h3>

        <h4 class="level">NIVEL 1</h4>

        <p class="exercise">Ejercicio 1</p>
        <p>
            Conversión de funciones: Tienes una función add que acepta dos parámetros y devuelve su add. Conviértela en
            una
            función de flecha. Por ejemplo: function add(a, b) {return a + b;}.</p>
        <script>
            /*
        OBJETIVOS:
        Comprender y practicar el uso de las funciones de flecha.
        Aprender y aplicar el operador ternario en distintos contextos.
        Entender y practicar con callbacks.
        Conocer y utilizar los operadores Rest y Spread.
        Familiarizarse con los bucles y las
        */
            const add = (a, b) => a + b;

            console.log("función flecha:add")
            console.log(add(7, 3)); //10
        </script>

        <p class="exercise"> Ejercicio 2 </p>
        <p> Función de flecha sin parámetros: Crea una función de flecha llamada randompnumber que no necesite
            parámetros
            y
            que devuelva un número aleatorio entre 0 y 100.</p>
        <script>
            const randomNumber = () => Math.ceil(Math.random() * 100);
            console.log("Función flecha: randomNumber");
            console.log(randomNumber());
        </script>

        <p class="exercise">Ejercicio 3</p>
        <p> Uso de 'this' en las funciones de flecha: Crea una clase person que tenga una propiedad name y una función
            greet
            que
            utilice una función de flecha. La función debe imprimir un saludo que incluya el nombre de la persona. Por
            ejemplo:
            console.log(Hola, ${this.name});.</p>
        <script>
            class Person {
                constructor(name) {
                    this.name = name;
                }

                greet = () => {
                    console.log(`Hola, ${this.name}`);
                }
            }

            let person = new Person("Bruno Díaz");
            person.greet(); // Hola, Bruno Díaz
        </script>


        <h4 class="level">NIVEL 2</h4>
        <p class="exercise"> Ejercicio 4</p>
        <p>Función de flecha dentro de un loop: Crea una función llamada printpnumbers que acepte un array de números y
            utilice
            un loop for para imprimir cada número en la consola utilizando una función de flecha.</p>

        <script>
            let num = [2, 5, 7, 9, 11];

            let printNumbers = (numbers) => {
                console.log(numbers);
            };

            for (let i = 0; i < num.length; i++) {
                printNumbers(num);
            }
        </script>

        <h4 class="level">NIVEL 3</h4>
        <p class="exercise">Ejercicio 5</p>
        <p>Función de flecha con 'setTimeout': Crea una función de flecha que imprima un mensaje en la consola después
            de
            esperar 3 segundos.</p>
        <script>
            setTimeout(() => {
                console.log("message delayed three seconds");
            }, 3000);
        </script>



        <h3 class="title"> Ejercicio 1.2: OPERADOR TERNARIO</h3>

        <h4 class="level">NIVEL 1</h4>

        <p class="exercise"> Ejercicio 1 </p>
        <p> Operador ternario básico: Escribe una función puedeConducir que acepte la edad como parámetro y utilice el
            operador
            ternario para determinar si el usuario puede conducir. Si la edad es 18 o más, debe devolver 'Puedes
            conducir'. Si
            no, debe devolver 'No puedes conducir'.</p>

        <script>
            //    let age = 22;
            //   (age >= 18) ? console.log("Puedes conducir!!"): ("No puedes conducir :(");

            let age = 22;
            const puedeConducir = (age) => (age >= 18) ? "Puedes conducir!!" :
                "No puedes conducir :(";
            console.log(puedeConducir(age));
        </script>

        <p class="exercise"> Ejercicio 2 </p>
        <p> Uso con operadores de comparación: Escribe una expresión que utilice el operador ternario para determinar
            cuál de
            los dos números dados (pnum1 y pnum2) es mayor. Si pnum1 es mayor, devuelve 'pnum1 es mayor'. Si no,
            devuelve
            'pnum2 es
            mayor'.</p>
        <script>
            let pnum1 = 5;
            let pnum2 = 2;
            let mayOmen = (pnum1 > pnum2) ? 'pnum1 es mayor' : 'pnum2 es mayor';
            console.log(mayOmen);
        </script>

        <h4 class="level">NIVEL 2</h4>

        <p class="exercise">Ejercicio 3</p>
        <p> Uso enlazado de operadores ternarios: Escribe una expresión que utilice enlaces de operadores ternarios para
            determinar si un número es positivo, negativo o cero.</p>

        <script>
            let numPNC = 0;
            let numSign = (numPNC > 0) ? console.log("El número es positivo!") : (numPNC < 0) ? console.log(
                "el número es negativo!") : console.log("El número es cero!");
        </script>

        <p> Operador ternario con funciones: Crea una función encontrarMaximo que acepte tres parámetros (a, b, c) y
            utilice
            el
            operador ternario para determinar el valor máximo.</p>

        <script>
            let a = 5;
            let b = 2;
            let c = 10;

            const encontrarMaximo = (a, b, c) => {
                let max =
                    (a > b && a > c) ?
                    "El valor máximo es: " + a :
                    (b > a && b > c) ?
                    "El valor máximo es: " + b :
                    "El valor máximo es: " + c;
                return max;
            };

            console.log(encontrarMaximo(a, b, c));
        </script>

        <h4 class="level">NIVEL 3</h4>
        <p class="exercise">Ejercicio 4</p>
        <p> Operador ternario dentro de un bucle: Escribe una función parOImpar que acepte un array de números y utilice
            un
            bucle para recorrer el array. Dentro del bucle, utiliza el operador ternario para determinar si cada número
            es par o
            impar.</p>
        <script>
            const numPoI = [1, 2, 3, 4, 5, 6];
            const pa = [];
            const imp = [];

            const parOimpar = (numPoi) => {
                for (let i = 0; i < numPoi.length; i++) {
                    numPoi[i] % 2 == 0 ?
                        (pa.push(numPoi[i]), console.log(pa + " son números pares")) :
                        (imp.push(numPoi[i]), console.log(imp + " son números impares"));
                }
            }

            parOimpar(numPoI);
        </script>

        <h3 class="title"> Ejercicio 1.3: CALLBACKS</h3>

        <h4 class="level">NIVEL 1</h4>

        <p class="exercise">Ejercicio 1</p>
        <p>Callback básico: Escribe una función llamada procesar que acepte dos parámetros: un número y una función de
            callback. La función procesar debe invocar la función de callback, pasando el número como parámetro.</p>

        <script>
            function procesar(numero, callback) {
                return callback(numero);
            }

            let result = procesar(5, function (num) {
                return num * 2;
            });

            console.log(result); // 10  
        </script>

        <p class="exercise">Ejercicio 2</p>
        <p>Callbacks con operaciones matemáticas: Escribe una función calculadora que acepte tres parámetros: dos
            números y una
            función de callback. La función calculadora debe invocar la función de callback con los dos números como
            parámetros.
            Luego, llama calculadora con una función que realice la add de los dos números.</p>

        <script>
            function calculadora(num1, num2, callback) {
                return callback(num1, num2);
            }

            function sumar(a, b) {
                return a + b;
            }

            let resp = calculadora(5, 10, sumar);
            console.log(resp); // 15
        </script>


        <h4 class="level">NIVEL 2</h4>

        <p class="exercise">Ejercicio 3</p>
        <p>Uso de callbacks en funciones asíncronas: Escribe una función esperarISaludar que acepte dos parámetros: un
            nombre y
            una función de callback. La función debe esperar 2 segundos y entonces invocar la función de callback,
            pasando el
            nombre como parámetro</p>.

        <script>
            let nombre = 'Peter Parker';

            function saludar(nombre) {
                console.log("Hola " + nombre);
            }

            function esperarYSaludar(nombre, callback) {
                setTimeout(() => {
                    callback(nombre);
                }, 2000);
            }

            esperarYSaludar(nombre, saludar); // Hola Peter Parker después de 2 segundos
        </script>

        <p class="exercise">Ejercicio 4</p>
        <p>Callbacks con arrays: Escribe una función procesarElements que acepte dos parámetros: un array y una
            función de
            callback. La función procesarElements debe invocar la función de callback por cada elemento del array.
        </p>

        <script>
            function procesarElements(arrayNum, callback) {
                arrayNum.forEach(element => {
                    callback(element);
                });
            }

            let arrayNum = [1, 2, 3, 4, 5];

            procesarElements(arrayNum, function (element) {
                console.log(element); // cada elemento del array 
            });
        </script>

        <h4 class="level">NIVEL 3</h4>

        <p class="exercise">Ejercicio 5</p>
        <p> Escribe una función procesarCadena que acepte dos parámetros: una cadena de caracteres y una función de
            callback. La
            función procesarCadena debe convertir la cadena a mayúsculas y entonces invocar la función de callback con
            la cadena
            transformada.
        </p>

        <script>
            function procesarCadena(cadena, callback) {
                // Convertir la cadena a mayúsculas
                var cadenaTransformada = cadena.toUpperCase();

                // Invocar la función de callback con la cadena transformada
                callback(cadenaTransformada);
            }
        </script>

        <h3 class="title"> Ejercicio 1.4: REST & SPREAD OPERATORS</h3>

        <h4 class="level">NIVEL 1</h4>

        <p class="exercise">Ejercicio 1</p>
        <p> Operador Spread en Arrays: Crea dos arrays, array1 y array2. Use el operador spread para crear una tercera
            array que
            contenga todos los elementos de array1 y array2.</p>

        <script>
            let arrayA = [1, 2, 3];
            let arrayB = [4, 5, 6];

            let arrayC = [...arrayA, ...arrayB];

            console.log(arrayC); // [1, 2, 3, 4, 5, 6]
        </script>


        <p class="exercise">Ejercicio 2</p>
        <p> Operador Rest en Funciones: Crea una función 'add' que utilice el operador rest para aceptar un número
            indeterminado de argumentos y devolver su add.</p>

        <script>
            let nums = [2, 5, 7, 9];

            function adicion(...nums) {
                //  "reduce" suma todos los números dentro del array
                return nums.reduce((total, num) => total + num, 0);
            }

            console.log(adicion(...nums)); // 23
        </script>
        <h4 class="level">NIVEL 2</h4>

        <p class="exercise">Ejercicio 3</p>
        <p>Copiando objetos con Spread: Crea un objeto 'objeto1'. Luego crea un segundo objeto, 'objeto2', que sea una
            copia de
            'objeto1' utilizando el operador spread. Cambia una propiedad de 'objeto2' y comprueba que 'objeto1' no ha
            cambiado.</p>
        <script>
            let objeto1 = {
                nombre: 'Pau',
                apellido: 'Gas',
                edad: 38,

            };

            let objeto2 = {
                ...objeto1
            };

            // Cambiamos una propiedad del objeto2
            objeto2.edad = 40;

            // Comprobamos si el objeto1 ha cambiado
            if (objeto1.edad === 38) {
                console.log("objeto1 no ha cambiado");
            } else {
                console.log("objeto1 ha cambiado");
            }
        </script>

        <p class="exercise">Ejercicio 4</p>
        <p>Resto en Destructuring: Crea un array con varios elementos. Utiliza destructuring y el operador resto para
            asignar
            los primeros dos elementos a variables, y después asignar el resto de los elementos a una tercera variable.
        </p>
        <script>
            let numeros = [1, 3, 6, 7, 9];

            let [primerNum, segundoNum, ...restoNum] = numeros;

            console.log(primerNum); // 1
            console.log(segundoNum); // 3
            console.log(restoNum); //  6, 7, 9
        </script>

        <h4 class="level">NIVEL 3</h4>

        <p class="exercise">Ejercicio 5</p>
        <p> Spread en Funciones: Crea una función que acepte tres argumentos. Después, crea un array con tres elementos
            y llama
            a la función utilizando el operador spread con esa array.</p>
        <script>
            function miFuncion(arg1, arg2, arg3) {
                console.log(arg1, arg2, arg3);
            }

            let array = [1, 2, 3];

            miFuncion(...array); //  1 2 3
        </script>

        <p class="exercise">Ejercicio 6</p>
        <p>Fusionando Objetos con Spread: Crea dos objetos con propiedades distintas. Utiliza el operador spread para
            fusionar
            estos dos objetos en uno nuevo.</p>

        <script>
            let objetoA = {
                nombre: 'Joan',
                edad: 40
            };

            let objetoB = {
                ciudad: 'Barcelona',
                profesion: 'Cocinero'
            };

            let objetoFusionado = {
                ...objetoA,
                ...objetoB
            };

            console.log(objetoFusionado);
            // { nombre: 'Joan', edad: 40, ciudad: 'Barcelona', profesion: 'Cocinero' }
        </script>

        <h3 class="title"> Ejercicio 1.5: ARRAY TRANSFORMATIONS</h3>

        <h4 class="level">NIVEL 1</h4>

        <p class="exercise">Ejercicio 1</p>
        <p>Map: Tiene un array de números [1, 2, 3, 4]. Crea un nuevo array que contenga el cuadrado de cada número.</p>

        <script>
            const array1 = [1, 2, 3, 4];
            const cuadrado = array1.map((x) => x * x);
            console.log("El cuadrado de los números del array  " + cuadrado);
            // [1, 4, 9, 16]
        </script>

        <p class="exercise">Ejercicio 2</p>
        <p>Filter: Tiene un array de números [1, 2, 3, 4]. Crea un nuevo array que sólo contenga los números pares.</p>

        <script>
            const lista = [1, 2, 3, 4];
            const nPares = lista.filter((x) => (x % 2) == 0);

            console.log("Los números pares del array son:  " + nPares); // [2,4]
        </script>

        <p class="exercise">Ejercicio 3</p>
        <p> Find: Tiene un array de números [1, 10 , 8, 11]. Use la función find para encontrar el primer número que es
            mayor a
            10.</p>
        <script>
            const arrayF = [1, 10, 8, 11];
            const firstNum = arrayF.find((numMayor) => numMayor > 10);

            console.log(firstNum); // 11
        </script>

        <p class="exercise">Ejercicio 4</p>
        <p> Reducción: Tiene un array de números [13, 7, 8, 21]. Utiliza la función reduccion para calcular la add
            total de los
            números.</p>
        <script>
            const arrayRed = [13, 7, 8, 21];

            const valorInicial = 0;
            const sumaArray = arrayRed.reduce((accumulator, valorActual) => accumulator + valorActual, valorInicial);

            console.log(sumaArray); //49
        </script>

        <h4 class="level">NIVEL 2</h4>

        <p class="exercise">Ejercicio 5</p>
        <p>Dado un array "[ 1, 3, 7, 10 ,15, 17, 11, 5, 8, 12, 9 ]", crea una función en una sola línea que haga lo
            siguiente:

            - Filtra los números mayores o iguales a 10.

            - Multiplica cada número filtrado por 2.

            - Calcula la add de los números filtrados y multiplicados por 2.

            - La función debe devolver el resultado de la add.</p>

        <script>
            let numberArray = [1, 3, 7, 10, 15, 17, 11, 5, 8, 12, 9];


            let respuesta = numberArray.filter(num => num >= 10).map(num => num * 2).reduce((a, b) => a + b, 0);

            console.log(respuesta); // 80


            const addic = (array) => array.filter(n => n >= 10).map(n => n * 2).reduce((a, b) => a + b);

            /*  filter(): para filtrar los números mayores o iguales a 10.
            map(): para multiplicar cada número filtrado por 2.
            reduce(): para calcular la add de los números filtrados y multiplicados por 2.
             */

            //addic([ 1, 3, 7, 10 ,15, 17, 11, 5, 8, 12, 9 ]); // 72
        </script>

        <h4 class="level">NIVEL 3</h4>
        <p class="exercise">Ejercicio 6</p>
        <p>Every / Some: Usa every y some para determinar si todos o algunos de los elementos del array [11, 12, 13,
            14] son ​​mayores que 10, respectivamente</p>

        <script>
            const numMay = numero => numero > 10;
            const numArray = [11, 12, 13, 14];

            console.log(numArray.every(numMay));
            console.log(numArray.some(numMay));
        </script>


        <h3 class="title"> Ejercicio 1.6: ARRAY LOOPS</h3>

        <h4 class="level">NIVEL 1</h4>

        <p class="exercise">Ejercicio 1</p>
        <p> forEach: Tiene un array de nombres. Utiliza forEach para imprimir cada nombre en la consola: let nombres =
            ['Anna',
            'Bernat', 'Clara'];</p>
        <script>
            let nombres = ["Anna", "Bernat", "Clara"];
            nombres.forEach(imprimirNombre);

            function imprimirNombre(nombre) {
                console.log(nombre);
            }
        </script>

        <p class="exercise">Ejercicio 2</p>
        <p> for-of: Tiene un array de nombres. Utiliza un bucle for-of para imprimir cada nombre en la consola: let noms
            =
            ['Anna', 'Bernat', 'Clara'];</p>

        <script>
            let noms = ['Anna', 'Bernat', 'Clara'];
            let resultado = "Contenido del Array es:";

            for (let valor of noms) {
                resultado += " " + valor + ",";
            }

            console.log(resultado);
        </script>

        <p class="exercise">Ejercicio 3</p>
        <p> filter: Tiene un array de números. Use filter para crear un nuevo array que sólo contenga los números
            pares. let
            pnumeros = [1, 2, 3, 4, 5, 6];</p>

        <script>
            const pnumeros = [1, 2, 3, 4, 5, 6];
            const pares = [];


            for (let i = 0; i < pnumeros.length; i++) {
                if (i % 2 == 0) {
                    pares.push(i)
                };
            }
            console.log(pares);
        </script>

        <h4 class="level">NIVEL 2</h4>

        <p class="exercise">Ejercicio 4</p>
        <p> for-in: Tiene un objeto con pares clave-valor: let obj = { nombre: Ola, edad: 25, ciudad: 'Barcelona' }; Use
            un
            bucle for-in para imprimir en la consola cada clave y su valor correspondiente.</p>

        <script>
            let obj = {
                nombre: "Ola",
                edad: 25,
                ciudad: 'Barcelona'
            };

            for (let property in obj) {
                console.log(`${property}: ${obj[property]}`);
            }
        </script>

        <p class="exercise">Ejercicio 5</p>
        <p> for-of con break: Tiene un array de números. Utiliza un bucle for-of para imprimir en la consola los números
            hasta
            encontrar el número 5, entonces detiene el bucle: let pnumeros = [1, 2, 3, 4, 5, 6];</p>

        <script>
            let pnum = [1, 2, 3, 4, 5, 6];


            for (let numCinco of pnum) {
                if (numCinco === 5) {
                    break;
                }
                console.log(numCinco);
            }
        </script>

        <h4 class="level">NIVEL 3</h4>
        <p class="exercise">Ejercicio 6</p>
        <p>for-of con index: Utiliza un bucle for-of para imprimir en la consola cada elemento del array y su posición
            (index):
            let noms = ['Anna', 'Bernat', 'Clara']</p>

        <script>
            let nom = ['Anna', 'Bernat', 'Clara'];

            for (let [index, name] of nom.entries()) {
                console.log(`Elemento en posición ${index}: ${name}`);
            }
        </script>

        <h3 class="title"> Ejercicio 1.7: PROMISES & ASYNC/AWAIT</h3>

        <h4 class="level">NIVEL 1</h4>

        <p class="exercise">Ejercicio 1</p>
        <p>Creación de una Promesa: Crea una promesa que se resuelva después de 2 segundos y que devuelva la cadena de
            texto
            'Hola, mundo'.</p>

        <script>
            let promesa = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Hola, a tothom');
                }, 2000);
            });

            promesa.then((mensaje) => {
                console.log(mensaje); //"Hola, a tothom"
            });
        </script>


        <p class="exercise">Ejercicio 2</p>
        <p>Utilización de una Promesa: Utiliza la promesa creada en el ejercicio anterior. Crea un .then que imprima el
            resultado en la consola.</p>
        <script>
            promesa.then((mensaje) => {
                console.log(mensaje); //"Hola, a tothom"
            });
        </script>

        <p class="exercise">Ejercicio 3</p>
        <p>Promesa con reject: Crea una promesa que se resuelva después de 2 segundos si el input es igual a 'Hola', y
            que la
            rechace si el input es cualquier otra cosa.</p>
        <script>
            function crearPromesa(input) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        if (input === 'Hola') {
                            resolve('La promesa ha sido resuelta');
                        } else {
                            reject('La promesa ha sido rechazada');
                        }
                    }, 2000);
                });
            }

            // Uso de la promesa
            crearPromesa('Hola')
                .then(console.log) //  promesa  resuelta
                .catch(console.error); // No se ejecuta
        </script>


        <p class="exercise">Ejercicio 4</p>
        <p> Uso de async/await: Escribe una función asíncrona que utilice la función await para esperar el resultado de
            la
            promesa creada en el ejercicio 1, y que después imprima este resultado en la consola.</p>
        <script>
            function crearPromesa(input) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        if (input === 'Hola') {
                            resolve('La promesa ha sido resuelta');
                        } else {
                            reject('La promesa ha sido rechazada');
                        }
                    }, 2000);
                });
            }
            crearPromesa('Hola')
                .then(console.log) //  promesa resuelta
                .catch(console.error); // No se ejecuta

            crearPromesa('Adios')
                .then(console.log) // No se ejecuta
                .catch(console.error); //  promesa rechazada
        </script>

        <h4 class="level">NIVEL 2</h4>

        <p class="exercise">Ejercicio 5</p>
        <p>Gestión de errores con async/await: Modifica la función del ejercicio 4 para que capture cualquier posible
            error
            utilizando un blog try/catch.</p>
        <script>
            async function crearPromesa(input) {
                try {
                    let resultado = await new Promise((resolve, reject) => {
                        setTimeout(() => {
                            if (input === 'Hola') {
                                resolve('La promesa ha sido resuelta');
                            } else {
                                reject('La promesa ha sido rechazada');
                            }
                        }, 2000);
                    });

                    console.log(resultado);
                } catch (error) {
                    console.error(error);
                }
            }


            crearPromesa('Hola'); //  promesa  resuelta
            crearPromesa('Adios'); // promesa  rechazada
        </script>

        <h4 class="level">NIVEL 3</h4>
        <p class="exercise">Ejercicio 6</p>
        <p>Promise.all: Crea dos promesas que se resuelvan después de 2 y 3 segundos, respectivamente. Use Promise.all
            para
            esperar que ambas promesas se resuelvan, e imprime los resultados en la consola.</p>

        <script>
            const promesa1 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Promesa 1 resuelta');
                }, 2000);
            });

            const promesa2 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('Promesa 2 resuelta');
                }, 3000);
            });

            Promise.all([promesa1, promesa2])
                .then(resultados => {
                    console.log(resultados); //  [ 'Promesa 1 resuelta', 'Promesa 2 resuelta' ]
                })
                .catch(error => {
                    console.error('Error:', error);
                });
        </script>
    </div>
</body>

</html>